# 인증(Authentication)과 인가(Authorization)

- 인증: 로그인과 같이 사용자가 누구인지 확인하는 절차
- 인가: 특정 리소스에 대해 접근 권한이 있는지 확인하는 절차
  - 보통 토큰을 사용해 자신의 인가 세부사항을 받음

→ 특정 리소스(서비스)에 접근하는 것을 보호하기 위해 인증과 인가가 필요

# 세션 기반 인증

- 쿠키: 클라이언트 로컬에 저장되는 key-value의 작은 데이터 파일
  - 사용자 인증이 유효한 시간 명시
  - Response Header에 Set-Cookie 속성을 사용하여 쿠키를 만듦
  - 사용자가 따로 요청하지 않아도 브라우저가 Request Header에 자동으로 넣어 서버로 전송
- 세션: 고유 ID, 로그인 시간 및 만료 시간 등의 사용자 정보를 저장하는 JSON 형식의 파일 - 쿠키를 기반으로 하며 서버측에서 관리 (보안에 더 좋음) - 브라우저가 서버에 접속하여 브라우저를 종료할 때까지 인증상태 유지
  ![Untitled](https://user-images.githubusercontent.com/55427367/212450686-17992644-e5fd-41d3-859b-81a4c534f87f.png)

1. 클라이언트가 서버로 username, pw등의 정보를 보내 로그인 요청
2. 서버는 DB의 유저 정보와 비교
3. 일치하는 경우 세션을 생성해 메모리를 저장하고, 세션ID를 클라이언트에 쿠키로 발급
4. 쿠키의 세션ID와 서버에 저장된 세션 데이터의 ID를 비교해 사용자의 신원 확인

### 장점

1. XSS 공격에 상대적으로 덜 위험
   - 서버에서 설정한 HTTP 쿠키는 JS로 읽을 수 없음
2. 강제 로그아웃 가능
   - 서버에서 저장된 세션을 무효화 시킬 수 있음

### 단점

1. 서버 확장이 어려움
   - 동시 접속자가 많을 경우, 세션을 모두 서버에 저장하기 때문에 서버에 과부하가 걸릴 수 있음
   - 서버를 여러대로 확장한다면 다른 서버에 접근할 때마다 다시 로그인을 하거나 다른 처리를 해야하기 때문에 번거로움
2. CSRF 공격에 노출될 수 있음
   - Referer 헤더 검증으로 해결
     - 현재 요청을 보낸 페이지의 부분 주소를 포함하여 도메인이 일치하는지 검증
   - CSRF 토큰을 활용하여 해결
     - 서버에서 랜덤으로 생성한 토큰을 input hidden으로 삽입하고 사용자 세션에도 저장
     - 사용자가 서버로 요청을 보낼 때 토큰 값이 전송되어 서버가 세션에 저장된 값과 토큰이 일치하는지 확인

💡
XSS 공격이란?

- _권한이 없는 사용자가 악의적인 용도로 웹 사이트에 스크립트를 삽입하는 공격 기법_
  CSRF 공격이란?
- _사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격_

# 토큰 기반 인증

- JWT(JSON Web Token): 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보 포함
- 세션보다 상대적으로 크기가 큼

![Untitled](https://user-images.githubusercontent.com/55427367/212450689-e6033b8f-a55e-4a9e-9e9e-d3e94d4206d1.png)

1. 클라이언트가 서버에게 로그인 정보를 보내 로그인 요청
2. 서버는 이 정보를 DB의 유저 정보와 비교
3. 일치하는 경우 비밀키를 사용해 토큰을 생성한 뒤 클라이언트에게 전송
4. 클라이언트는 받은 토큰 저장 (보통 localStorage사용)
5. 인증이 필요한 요청을 보낼 때 Authorization 헤더로 토큰을 설정하여 서버로 보냄
6. 서버가 토큰을 복호화하여 유효성을 검증하고 정보 확인

### 장점

1. 확장성
   - 로그인 유저수에 대해 서버가 영향을 받지 않음
2. CSRF 공격에 위험성 없음
   - 보통 localStorage에 저장하기 때문에 서버로 전송되지 않음

### 단점

1. XSS 공격이 발생했을 때 상대적으로 위험
   - localStorage에 저장된 값은 JS로 읽을 수 있기 때문에 탈취될 수 있음
   - accessToken의 만료 시간을 짧게 하고, refreshToken으로 갱신 하는 방법으로 해결
     - refereshToken을 httpOnly 쿠키로 저장하는 것이 안전

# OAuth

- 사용자들이 비밀번호를 제공하지 않고 다른 퉵사이트의 정보에 대해 접근 권한을 부여하는 방식 (Google, Naver, Kakao 로그인 등)
  ![Untitled](https://user-images.githubusercontent.com/55427367/212450694-73cdbde7-a12d-4793-b18e-754fff240069.png)

1. 사용자가 클라이언트(서비스)를 이용하기 위해 로그인 페이지에 접근하여 OAuth 로그인 버튼을 누른다.
2. 특정 url이 Resource Server로 넘어가며 클라이언트 보낸 정보와 로그인 서버에 등록된 정보를 확인한다.
3. 확인이 완료되면 전용 로그인 페이지를 사용자에게 제공한다.
4. 사용자는 로그인을 하고 클라이언트가 이용하려는 기능에 대해 동의 요청을 보낸다.
5. 사용자가 Allow 버튼을 누르면 Resource Server에 전달된다.
6. Resource Server도 권한 승인을 하기 위해 Authorization code를 Redirect URL을 사용해 사용자에게 응답한다.
7. 사용자는 그 URL을 그대로 클라이언트에게 보낸다.
8. 클라이언트는 Authorization Code를 사용자를 통해 받고 이를 직접 Resource server에게 보낸다.
9. Resource Server는 Access Token을 발급하고 클라이언트는 사용자에게 로그인이 되었다고 응답한다.
10. 사용자가 서비스 요청을 하게 된다면 Access Token으로 API 호출을 하여 서비스를 제공하게 된다.
