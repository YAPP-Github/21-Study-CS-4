# 메모리 주소

## 논리적 주소

- 각 프로세스마다 독립적으로 가지는 주소 공간
- 각 프로세스마다 0번지 부터 시작
- CPU가 보든 주소는 논리적 주소

## 물리적 주소

- 메모리에 실제로 올라가는 위치
- 논리적 주소를 물리적 주소로 변환하는 과정을 주소 바인딩이라고 함
    - Compile time binding
    - Load time binding
    - Run time binding

# 메모리 관리 장치 : MMU

<aside>
💡 논리적 주소를 물리적 주소로 변환해준다
메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리한다

</aside>

## 역할

1. 물리적 주소를 직접 접근해야 하는 부담을 없애준다
2. 사용자가 공간을 일일이 할당해야 하는 불편을 없애준다
3. 프로세스의 크기가 실제 메모리 용량을 초과해도 실행될 수 있게 해준다
4. 프로세스를 실행하기 위해 필요한 코드와 데이터를 가져와 메모리에 적재한다
5. 메모리를 보호한다
    1. 다른 프로세스가 현재 프로세스 주소 공간에 접근하는 것을 막거나
    2. 악의적인 프로세스가 금지된 주소 공간에 접근하는 것을 막는다
6. 캐시를 관리하여 CPU와 메인 메모리 간의 속도를 맞춘다

# 메모리 관리 기법

메모리 과할당 문제를 해결하기 위해 다음과 같은 관리 기법들이 존재한다

- 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황

## Swaping

<aside>
💡 프로세스의 전체 수행 이미지를 연속적인 메모리에 적재하여 실행하다가 
실행되지 않으면 하드디스크의 swap 영역로 내보내는 방법이다.

swap 영역의 프로세스는 다시 실행되면 메모리로 올려진다

</aside>

### 단점

`외부 단편화`가 생길 수 있다

또한 메모리가 꽉 찼을 때 실행 중인 프로세스의 크기가 증가한다면 실행 중이던 다른 프로세스를 스왑 영역으로 보내야하는데, 스왑 영역마저 꽉 차 있으면 증가하려는 프로세스를 중단시키거나 강제로 종료시켜야 한다. 

이 문제를 해결하려면 프로세스가 실행 중에 증가할 것을 예상하여 `메모리에 적재할 때 여분의 공간`을 제공해주어야한다.

### 단편화

<aside>
💡 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간

</aside>

- 외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 **분산되어 있을때 발생한다고 볼 수 있다.**
- 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 **메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이** 가 존재하고, 이 현상을 내부 단편화라 칭한다.

## Paging

<aside>
💡 하나의 프로세스가 사용하는 메모리는

1. 여러개의 페이지로 나뉘고
2. 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑된다
</aside>

논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고 

물리 메모리의 남는 프레임에 적절히 배치된다

- 물리 메모리는 프레임이라는 고정 크기로 분리된다
- 논리 메모리는 페이지라 불리는 고정 크기로 분리된다

### 단점

페이지 내부에 잉여 공간이 남게 되는 `내부 단편화` 문제가 생길 수 있다

## Segmentation

<aside>
💡 페이징과 비슷하지만, 논리 메모리와 물리 메모리를 
서로 다른 크기의 논리적 단위인 세그먼트로 분할한다

</aside>

- 세그먼트 테이블에는 각 세그먼트의 시작 물리주소와 길이를 저장한다

### 단점

서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면

역시 `외부 단편화` 문제가 생길 수 있다
