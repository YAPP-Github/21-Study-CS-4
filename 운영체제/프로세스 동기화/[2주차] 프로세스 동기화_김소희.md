# 동기와 비동기

<aside>
💡 동기와 비동기는 작업을 수행하는 시간에 관점을 둔다
 1. 두 개 이상의 주체가 작업 시간을 똑같이 맞출 때
 2. 서로 맞추지 않을 때

또는 작업 완료 여부 확인에 관점을 둘 수 있다
 1. 작업 완료가 될 때까지 기다릴 때 또는 중간에 계속 확인할 때
 2. 작업 완료 여부를 신경쓰지 않을 때

</aside>

## 동기

> 메소드를 실행 시킴과 동시에 반환 값이 기대되는 경우
> 두 가지 이상의 대상(함수, 애플리케이션)이 서로 시간을 맞춰 행동하는 것

![image](https://user-images.githubusercontent.com/74011724/205045569-0f1d8cdb-6242-4933-8131-5aa564c80972.png)


- A의 끝나는 시간과 B의 시작하는 시간을 맞추기
- 호출한 함수가 호출된 함수의 작업이 끝나 결과를 반환하기를 기다리기
- 현재 작업의 응답이 끝남과 동시에 다음 작업이 요청

![image](https://user-images.githubusercontent.com/74011724/205045631-a0200d86-34c9-4798-8d8d-08e39594e9ce.png)


- 시작 시간과 종료 시간 같이 맞추기
- 메소드 리턴 시점과 결과를 전달 받은 시점이 일치하는 경우
- 작업 완료 여부를 계속해서 확인하기 (Polling)

## 비동기

> 두 가지 이상의 대상이 각자 별도의 시작 시간과 끝나는 시간을 가지고 있을 경우
> 

![image](https://user-images.githubusercontent.com/74011724/205045680-d609e501-c78f-4dfc-965a-5681d14b788f.png)


- 작업 완료 여부를 확인하지 않음
- 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청
- 시작 시간과 종료 시간이 일치하지 않음

---

# Blocking vs Non-Blocking

<aside>
💡 제어권이 어디에 있느냐에 대한 관점이다

 1. 작업을 시킨 주체에게 있는가
 2. 작업을 처리하는 주체에게 있는가

</aside>

## Blocking

> 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주는 경우
> 

![image](https://user-images.githubusercontent.com/74011724/205045716-764fb3d5-6ae3-4630-b0ed-9aa13ca391e6.png)


- 호출하는 함수가 I/O 작업을 요청할 때 처리가 완료될 때까지 아무 일도 못하고 기다리는 것
- 제어권이 없는 상태에서는 Blocking이 되며 다른 일을 할 수 없다

## Non-Blocking

> 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 경우
> 

![image](https://user-images.githubusercontent.com/74011724/205045745-6453a73f-ea32-441c-96d8-a9be9eb9fae8.png)


- 호출되는 대상의 작업 처리 여부와 상관없이 바로 자신의 작업을 수행할 수 있다
- 제어권을 호출 주체에게 바로 돌려준다

---

# 4가지 조합

## 1. Synchronous Blocking I/O

![image](https://user-images.githubusercontent.com/74011724/205045782-47a2a35c-07e1-4cf1-91c6-1eef79788d17.png)

- Synchronous : read가 리턴하는 시간과 커널에서 결과를 가져오는 시점이 일치한다
- Blocking : read가 완료될 때까지 제어권을 넘기며 다음 작업을 수행하지 못하고 기다린다

## 2. Synchronous Non-Blocking I/O

![image](https://user-images.githubusercontent.com/74011724/205045821-bcffd877-0074-4ee3-988d-a0db81e192bd.png)

- Synchronous : read가 리턴하는 시간과 커널에서 결과를 가져오는 시점이 일치한다
- Non-Blocking : 커널은 작업 완료 여부와 상관없이 제어권을 바로 어플레케이션에 넘겨준다

## 3. Asynchronous Non-Blocking I/O

![image](https://user-images.githubusercontent.com/74011724/205045853-b8fa534d-faa2-47a8-8f1f-40ebd76db0a8.png)

- 가장 많이 쓰이는 조합 중 하나이다.
- 성능과 자원의 효율면에서 가장 우수하다.
- Asynchronous : aio_read가 리턴하는 시간과 커널에서 결과를 가져오는 시간이 불일치 한다
- Non-Blocking : 커널은 작업 완료 여부와 상관없이 제어권을 바로 어플레케이션에 넘겨준다

## 4. Asynchronous Blocking I/O

- 별 다른 장점이 없어서 일부러 사용할 필요는 없다
- 그러나 Async Non-Blocking을 사용하는 과정에서 하나라도 Blocking 방식을 사용하는 함수가 있다면 의도치 않게 Async Blocking 방식으로 작동할 수 있다.
- Node.js + MySQL의 조합이 대표적인데, Node.js에서 비동기(async)적으로 DB 작업을 수행하더라도 Blocking 방식으로 작동하는 MySQL 드라이버를 거치게 된다.


> 레퍼런스 : [https://velog.io/@guswns3371/운영체제-Synchronous와-Asynchronous-Blocking과-Non-Blocking](https://velog.io/@guswns3371/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Synchronous%EC%99%80-Asynchronous-Blocking%EA%B3%BC-Non-Blocking)


---

# 프로세스의 동기화

# 경쟁 상태

공유 자원에 대해 `여러 프로세스가 동시에 접근`할 때, 결과값에 영향을 줄 수 있는 상태

동시 접근 시 자료의 일관성을 해치는 결과가 나타난다

## 공유 자원

1. 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일
2. 누가 언제 데이터를 읽고 쓰느냐에 따라 결과가 달라질 수 있다
3. `프로세스들의 공유 자원 접근 순서`를 정해 문제가 발생하지 않도록 주의해야 한다

## 발생하는 경우

### 커널 코드 실행 중 인터럽트

커널모드에서 데이터를 로드하여 작업을 하던 도중 인터럽트가 발생하여 같은 데이터를 조작하는 경우에 발생할 수 있다.

**커널이 가진 전역변수는 모든 프로세스의 공유물**이므로 경쟁상태의 가능성이 있다.

### 프로세스가 시스템 콜을 하여 커널 모드로 진입해 작업을 수행하는 중 문맥 교환

프로세스1이 커널모드에서 데이터를 조작하던 도중 시간이 초과되어 

CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우를 말한다.

### 멀티 프로세스 환경에서 공유 메모리 내의 커널 데이터에 접근

멀티프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우에 발생할 수 있다.

## 임계 구역 : Critical Section

<aside>
💡 여러 프로세스의 접근 순서에 따라 실행 결과가 달라질 수 있는 코드 부분

</aside>

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에 

**한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다**

- 어떤 프로세스가 임계 구역에 들어가면 다른 프로세스는 밖에서 기다려야 하고
- 임계 구역의 프로세스가 작업을 끝마쳐야 새로운 프로세스가 작업을 시작할 수 있다

### 생산자 소비자 문제

생산자는 계속 물건을 생산해서 버퍼에 넣고, 소비자는 계속 버퍼에서 물건을 가져온다

버퍼 내부 물건의 개수를 확인하기 위해 **임계 구역인 전역 변수 sum**을 사용한다

여기서 생산자와 소비자가 전역 변수 sum에 접근하는 타이밍을 서로 맞추지 않으면 문제가 발생한다

- 소비자 또는 생산가 버퍼를 건드린 후 sum을 갱신하지 못한 채, 상대 프로세스로 문맥 교환이 되면 경쟁 상태가 발생한다

## 임계구역 문제의 해결 조건

상호 배제 만으로 경쟁 상태를 피할 수 있지만 

멀티 프로세스에서 발생하는 다른 문제들도 해결하기 위해 나머지 두 조건도 필요하다

### 상호 배제 : Mutaul Exclusion

- 한 프로세스가 임계 구역에 들어가면, 다른 프로세스는 임계 구역에 들어갈 수 없다
- 임계 구역 내에는 한 번에 하나의 프로세스만 있어야 한다

### 진행 : Progress

- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다
- 모든 프로세스가 임계 구역에 들어가있지 않는 상태임이 확인된다면, 진입을 희망하는 프로세스를 임계 구역에 들어가도록 허용해주어야 한다.

### 한정된 대기 : Bounded Wating

- **어떤 프로세스도 무한 대기(infinite postpone)하지 않아야 한다**
- 즉, 특정 프로세스가 임계 구역에 진입하지 못하면 안된다

# 동기화 기법

## 세마포어

<aside>
💡 세마포어는 프로세스나 스레드 간 동기화를 위해 사용한다. 
자원의 가용 개수를 나타내는 정수 변수를 값으로 가진다. 

wait 연산으로 이 값을 감소시키고 signal 연산으로 증가시키는데, 원자적 연산이으로 연산이 완료되기 전까지 다른 프로세스가 세마포어에 접근할 수 없도록 보장한다.

따라서 한 번에 하나의 프로세스(스레드)만이 값의 변경을 수행할 수 있다.

</aside>

### 카운팅 세마포어

**가용한 개수를 가진 자원**에 대한 접근 제어용으로 사용되며, 세마포어는 그 가용한 **자원의 개수**로 초기화 된다. 

자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가 한다.

### 이진 세마포어 (Mutex)

Mutex 라고도 부르며, 상호배제의 (Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 

이름 그대로 0 과 1 사이의 값만 가능하며, 다중 프로세스들 사이의 임계 구역 문제를 해결하기 위해 사용한다

### 단점 : Deadlock

![image](https://user-images.githubusercontent.com/74011724/205046299-f60545bd-b312-426b-8b45-d9d17dc10687.png)

**서로 다른 두 프로세스가 wait 상태에 있는 자원을 요청하는 경우이다**

- 둘 이상의 프로세스가 임계 구역 진입을 무한정 기다리고 있고
- 임계 구역에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황

## 뮤텍스

<aside>
💡 세마포어와 마찬가지로 프로세스와 스레드 간 동기화를 위해 사용한다
이진 세마포어와 같이 초기 값을 0과 1로 가진다

임계 영역에 들어갈 때 락을 걸어 다른 프로세스가 접근하지 못하게 하고,
임계영역에서 나와 해당 락을 해제 한다

</aside>

### 뮤텍스와 세마포어의 차이

**접근 가능 개수**

세마포어 : 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있다. 

뮤텍스 : **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있다.

**락 해제 주체**

세마포어 : 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있다.** 

뮤텍스 : **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 한다.
