
가상 메모리는 실제 메모리 용량보다 더 많은 양의 공간을 필요로 하는 프로그램을 실행하게 해준다

이러한 동작이 가능하기 위해서
 1. 가상의 커다란 프로세스 기억 공간을 정해진 방법으로 분할하고
 2. 그 중 현재 필요한 부분만 메모리에 적재되도록 한다


이를 위해 프로세스에 의해 참조되는 주소를 실제 메모리에서 사용하는 주소와 분리한다

또한 필요한 영역을 적절한 시점에 메모리에 가져온다

- 메모리가 모두 사용되고 있을 때는, 적절한 대상을 선택하여 필요한 페이지와 교체해야 한다

# 개념

![image](https://user-images.githubusercontent.com/74011724/208626470-362fa327-ba3b-47e1-849b-016ccf07d542.png)


> 프로세스에 의해 참조되는 주소(가상 주소)를 메모리에서 사용하는 주소(물리적 주소)와 분리하는 것
> 

프로세스는 오직 가상 주소만을 참조하지만, 그들은 실제로 메모리에서 실행 되어야 한다

**따라서 프로세스가 실행되면 가상주소를 실주소로 변환해야 하는데 이 과정을 사상이라고 한다**

또한 프로세스 실행 중 가상 주소를 실주소로 바꾸는 절차를 **동적 주소 변환(DAT)**이라고 한다

## 역할

1. **시스템 라이브러리가 여러 프로세스들 사이에서 공유될 수 있도록 한다**
    1. 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다
2. **프로세스 간 공유 메모리를 가능하게 하고, 이를 통해 통신할 수 있다**
    1. 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만 실제로 물리 메모리는 공유되고 있다
3. **fork를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다**

# 블록 단위 주소 변환

![image](https://user-images.githubusercontent.com/74011724/208626522-85a1f727-f38d-45b9-9aa1-81039d38b783.png)


동적 주소 변환 방법은 가상 메모리에서의 위치가 현재 메모리의 어디에 위치하는지 나타내는 

주소 변환 사상표를 유지해야 한다

- 사상 정보 양을 줄이기 위해 바이트나 워드 단위로 분류하는 것이 아니라 **블록 단위로 분류**한다
- 각 블록이 주기억장치의 어디에 위치하는지만을 관리한다

블록이 커지면

1. 사상 정보를 저장할 메모리 크기가 작아진다
2. 커다란 블록을 메모리에서 보조기억장치로 이동하는 데 필요한 전송 시간이 길어진다

블록의 크기가 동일하면 페이지라고 부르고, 이러한 가상 메모리 구성을 페이징 기법이라 한다

반대로 크기가 다르다면 세그먼트라 하고, 이러한 구성을 세그먼테이션 기법이라 한다

이 두 기법을 결합하여 **고정된 크기의 페이지로 이루어진 다양한 크기의 세그먼트**를 구현할 수도 있다

# 페이지 호출 기법

## 요구 페이지 : demand page fetch

> **한 프로세스의 페이지 요구가 있을 때** 요구 페이지를 메모리로 이동하는 것이다
> 

각 페이지는 **실행 중인 프로세스에 의해 명백히 참조될 때**에만 보조기억장치에서 메모리로 옮겨진다

- 프로세스의 실행 순서는 정확히 예측될 수 없기 때문에
- 명령어나 데이터가 실제로 참조되면 해당 페이지를 메모리에 적재한다

옮길 페이지를 결정하는 오버헤드를 최소화 시키며

메모리에 옮겨진 페이지는 모두 프로세스가 실제로 참조하는 것임을 확신할 수 있다

## 예상 페이지 : prepaging

> 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 옮겨놓는다
> 

예상이 옳았다면 실제로 필요한 시점이 되었을 때 프로세스의 실행이 단절되지 않아 실행 시간이 감소한다

프로세스가 시작할 때 요구 페이지 기법만을 사용한다면 메모리에는 첫 번째 페이지만 적재될 것이다

이후 프로세스 실행이 진행되면서 **연속적으로 페이지 부재(page fault)**가 발생하고

해당 페이지가 메모리로 옮겨지며 시작 시점에 성능이 저하될 것이다

**따라서 프로세스가 시작할 때 예상 페이지 호출 기법을 사용하면 성능이 개선된다**

# 페이지 교체 기법

> 운영체제는 메모리에 새로 적재될 페이지를 위해 
적절한 교체 대상 페이지를 선택하고 보조기억장치에 보관한 후 새로운 페이지를 적재해야 한다
> 

**최적화 원칙 : 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택하는 것**

미래를 예측할 수 없기 때문에 실현은 불가능하지만

다른 페이지 교체기법들이 얼마나 최적성을 갖고 있는지 비교하는 데 사용된다

- 또한 시간/공간 오버헤드가 적은 방법을 선택해야 한다

그러나 효율적인 동작을 위해 교체가 일어나면 안되는 페이지들도 있다

- 슈퍼바이저 코드
- 커널에 속하지 못한 보조기억장치 드라이버
- 시간을 맞춰 동작해야 하는 코드
- 입출력장치로부터 직접 데이터가 교환되는 데이터 버퍼

## 1. FIFO : First In First Out

> 한 페이지를 교체할 때는 메모리 내에 가장 오래 있었던 페이지를 교체한다
> 

그러나 메모리에 가장 오래 있던 페이지는 앞으로도 계속 사용될 가능성이 있다

- 가장 많이 쓰이는 페이지를 교체 시킬 가능성이 있다

또한 `Belady 이상 현상`이 일어날 수 있다

프로세스에 페이지 프레임을 더 많이 할당할 경우 오히려 페이지 부재가 더 발생할 수 있다는 것이다

## 2. LRU : Least Recently Used

> 가장 오랫동안 사용되지 않는 페이지를 교체한다
> 

LRU 기법은 Belady 이상현상이 발생하지 않고 많은 경우 최적화 원칙에 근사한 선택을 할수 있다

그러나 막대한 오버헤드가 있어 별로 사용되지 않는다

- 매번 시간을 기록하기
- 가장 오래된 참조시간 찾기
- 리스트 등 자료구조 유지

## 3. LFU : Least Frequently Used

> 참조한 횟수가 가장 적은 페이지가 교체된다
> 

그러나 가장 드물게 이용된 페이지가 최근에 메모리로 옮겨진 페이지일 가능성이 있다

- 이 페이지를 교체 시키고, 다시 메모리로 재호출 될 것이다

또한 초기에 매우 많이 사용되고 더이상 사용되지 않는 페이지는 교체되지 않는다

LRU와 마찬가지로 오버헤드도 크다
